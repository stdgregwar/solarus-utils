shader{
-- See : https://github.com/mattdesl/lwjgl-basics/wiki/2D-Pixel-Perfect-Shadows
vertex_source=
[[
    #version 330

    uniform mat4 sol_mvp_matrix;
    uniform mat3 sol_uv_matrix;
    in vec2 sol_vertex;
    in vec2 sol_tex_coord;
    in vec4 sol_color;

    out vec2 sol_vtex_coord;
    void main() {
      vec2 pos = sol_vertex*2-vec2(1,1);
      gl_Position = vec4(pos,0,1);
      sol_vtex_coord = sol_tex_coord;
    }
]],
fragment_source=
[[
    #version 330
    #define PI 3.14

    //inputs from vertex shader
    in vec2 sol_vtex_coord;

    //uniform values
    uniform sampler2D sol_texture;
    uniform vec2 resolution;

    //alpha threshold for our occlusion map
    const float THRESHOLD = 0.75;

    out vec4 color;

    void main(void) {
      float distance = 1.0;
      float last = 0.0;
      float lastd = distance;
      for (float y=0.0; y<resolution.y; y+=1.0) {
        		//rectangular to polar filter
        		vec2 norm = vec2(sol_vtex_coord.s, y/resolution.y) * 2.0 - 1.0;
        		float theta = PI*1.5 + norm.x * PI; 
        		float r = (1.0 + norm.y) * 0.5;
        		
        		//coord which we will sample from occlude map
        		vec2 coord = vec2(-r * sin(theta), -r * cos(theta))/2.0 + 0.5;
        		
        		//sample the occlusion map
        		vec4 data = texture2D(sol_texture, coord);
        		
        		//the current distance is how far from the top we've come
        		float dst = y/resolution.y;
        		
        		//if we've hit an opaque fragment (occluder), then get new distance
        		//if the new distance is below the current, then we'll use that for our ray
        		float caster = data.a;
        		if (last > THRESHOLD && caster < last) {
        			distance = min(distance, lastd);
        			//NOTE: we could probably use "break" or "return" here
        		}
          last = caster;
          lastd = dst;
        } 
        color = vec4(vec3(distance), 1.0);
    }
]]
}